
=head1 NAME

magnetogram2wind - FLUX Main Pipeline Script - A script to run the entire FLUX pipeline on a single Carrington Rotation (CR).

=cut

use strict;
use warnings;
use PDL;
use PDL::AutoLoader;
use PDL::Transform;
use PDL::NiceSlice;
use PDL::Options;

use Flux;
use PDL::IO::Misc;
use File::Path;
use File::Find;
use Time::HiRes    qw(clock_gettime sleep);
use File::Basename qw(fileparse);

# Makes sure the current directory is always in the path
use FindBin qw($RealBin);
use lib $RealBin;
use pdl_pipe_helper;
set_paths();

$PDL::BIGPDL = 1;


=head1 SYNOPSIS

    pdl magnetogram2wind.pdl [options]

=head1 DESCRIPTION

This script automates the entire FLUX pipeline for a given Carrington Rotation (CR). The pipeline consists of several stages:

=over 4

=item 1. Downloading the Magnetogram

=item 2. Processing the Magnetogram to find footpoints

=item 3. Running the Python PFSS Code to trace the footpoints into the corona

=item 4. Generating an initial FLUX world from the PFSS output

=item 5. Relaxing the initial world state using the FLUX code

=item 6. Plotting the world states

=item 7. Computing and plotting the solar wind and other derived quantities

=back


=head1 OPTIONS

Various options can be set within the script, such as:

=over 4

=item * C<$do_download> - Flag to download the magnetogram.

=item * C<$force_process_magnetogram> - Flag to force the processing of the magnetogram.

=item * C<$do_pfss> - Flag to run the PFSS code.

=item * C<$makeworld> - Flag to create the world.

=item * C<$do_relax> - Flag to relax the world.

=item * C<$do_png> - Flag to generate PNG plots.

=item * C<$do_interactive> - Flag to open a gnuplot window.

=item * C<$do_wind_calc> - Flag to calculate the solar wind.

=back

=head1 NOTES

Until the homebrew issues are fixed, plot using the command: C<$world -> render({'dev'=>'qt'})>.

=head1 AUTHOR

Gilly <gilly@swri.org> (and others!)

=head1 SEE ALSO

L<PDL>, L<PDL::AutoLoader>, L<PDL::Transform>, L<PDL::NiceSlice>, L<PDL::Options>, L<Flux>, L<PDL::IO::Misc>, L<File::Path>, L<Time::HiRes>, L<File::Basename>, L<pdl_pipe_helper>

=cut

sub configurations {
    my ($debug, $config_name, $config_filename) = @_;
    $config_name //= "DEFAULT";
    $config_filename //= "config.ini";
    $debug //= 0;

    use Config::IniFiles;
    use Cwd;
    use File::Spec::Functions;
    use File::Find;
    use File::Temp qw/ tempfile tempdir /;


    # Define the path of the configuration file
    my $config_path = catfile("fluxon-mhd", "flux-pipe", "config", $config_filename);

    # Check if the file exists at the defined path
    unless (-e $config_path) {
        my $found = 0;
        find(sub {
            if ($_ eq $config_filename) {
                $config_path = $File::Find::name;
                $found = 1;
            }
        }, getcwd());
        die "Configuration file not found." unless $found;
    }

    # Create a temporary file to store the config data without comments
    my ($fh, $temp_filename) = tempfile();

    # Remove inline comments and write to temporary file
    open(my $in, '<', $config_path) or die "Could not open '$config_path' for reading: $!";
    while (<$in>) {
        s/#.*$//;  # Remove inline comments
        s/\s+$//;  # Remove trailing whitespace
        print $fh "$_\n";  # Append a newline character, then print to file
    }
    close $in;
    close $fh;

    # Read the configuration file
    my $cfg = Config::IniFiles->new( -file => $temp_filename );

    # Select the correct section
    $config_name = $cfg->val('DEFAULT', 'config_name') if ($config_name eq 'DEFAULT');

    # Load all parameters from the DEFAULT section
    my %the_config = ();
    for my $key ($cfg->Parameters('DEFAULT')) {
        $the_config{$key} = $cfg->val('DEFAULT', $key);
    }

    # If a different section is specified, load its parameters, overwriting defaults where applicable
    if ($config_name ne 'DEFAULT') {
        $config_name = $cfg->val('DEFAULT', 'config_name') if ($config_name eq 'DEFAULT');
        for my $key ($cfg->Parameters($config_name)) {
            $the_config{$key} = $cfg->val($config_name, $key);
        }
    }

    # Perform additional processing on the configuration settings
    $the_config{'abs_rc_path'} = glob($the_config{'rc_path'});
    $the_config{"run_script"} = catfile($the_config{'fl_prefix'}, $the_config{"run_script"});

    # Remove brackets from rotations and fluxon_count
    $the_config{"rotations"} =~ s/[\[\]]//g;
    $the_config{"fluxon_count"} =~ s/[\[\]]//g;

    # Create PDL objects
    $the_config{"rotations"} = PDL->new(split(/\s*,\s*/, $the_config{"rotations"}));
    $the_config{"fluxon_count"} = PDL->new(split(/\s*,\s*/, $the_config{"fluxon_count"}));

    $the_config{"n_jobs"} = $the_config{"rotations"}->nelem * $the_config{"fluxon_count"}->nelem;


    if ($debug){
        #Print the content of the configuration hash for debugging.
        print "Configuration file values:\n--------------------------------\n";
        foreach my $key (keys %the_config) {
            print "$key: $the_config{$key}\n";
        }
        print "--------------------------------\n\n";
    }
    return %the_config;
}




#######################################################################################################
## Job Settings #######################################################################################
#######################################################################################################

# Read configurations from disk
my %configs = configurations();

my $CR = $ARGV[0] // ($configs{rotations}->at(0));
my $n_fluxons_wanted = $ARGV[1] // ($configs{fluxon_count}->at(0));

if (!defined $ARGV[0] and $configs{verbose}) {
    print "Using first value ($CR) from config for Carrington Rotation.\n";
}

if (!defined $ARGV[1] and $configs{verbose}) {
    print "Using first value ($n_fluxons_wanted) from config for fluxon count.\n\n";
}

my $pythondir          = $configs{python_dir};
my $basedir            = $configs{base_dir};
my $reduction          = $configs{mag_reduct};
my $recompute          = $configs{recompute};
my $batch_name         = $configs{batch_name};
my $plot_only          = $configs{plot_only};
my $lim                = $configs{inner_fov};
my $lim2               = $configs{outer_fov};
my $do_steps           = $configs{do_steps};   # relaxation steps between checking stiffness target
my $relax_threshold    = $configs{relax_threshold};  # stiffness target percent to stop relaxation
my $max_cycles         = $configs{max_cycles};
my $do_wind_calc       = $configs{do_wind_calc};
my $print_dirs         = $configs{verbose};

my $recompute_string = 'FALSE';
my ($this_world_relaxed, $N_actual);

#############################################################################
#### Initialize Environment #################################################
#############################################################################

my $do_download               = 0 // $configs{do_download};
my $force_process_magnetogram = 0;
my $do_pfss                   = 0;
my $makeworld                 = 0;
my $do_relax                  = 0;
my $do_png                    = 0;
my $do_interactive            = 0;

if ($recompute) {
    $force_process_magnetogram  = 1;
    $recompute_string           = 'TRUE';
    $do_pfss        = 1;
    $makeworld      = 1;
    $do_wind_calc   = 1;
    $do_relax       = 1;
    $do_png         = 1;
}


my ( $pipedir, $pdldir, $datdir, $magdir, $batchdir, $logfile ) =
  calculate_directories( $basedir, $batch_name, $print_dirs );


print_banner( $batch_name, $CR, $reduction, $n_fluxons_wanted,
    $recompute_string );

my $very_beginning = clock_gettime();





#### BEGIN ##################################################################





if ( not $plot_only ) {

#######################################################################################################
## Download the Magnetogram ###########################################################################
#######################################################################################################
    my $mag_command = "$pythondir $pipedir/get_magnetograms.py --cr $CR --reduce $reduction " .
                                            "--datdir $datdir --do_download $do_download";

    system($mag_command) == 0 or ( die "Python script returned error $?", exit );



#######################################################################################################
## Process the Magnetogram ## Find the Root Points ####################################################
#######################################################################################################
# The hilbert curve code defines where fluxons should be rooted based on the distribution of flux at 1R_sun.
# Since each contains a discretized amount of magnetic flux, we need to subdivide the domain to reflect how to represent that with fluxons.
    my $flocdir  = "$batchdir/cr$CR/floc";
    my $flocfile = "$flocdir/floc_cr$CR\_r$reduction\_f$n_fluxons_wanted.dat";
    my $magfile  = $magdir . "/CR$CR\_r$reduction\_hmi.fits";

    # Get the Footpoints
    my $N_actual =
      get_hilbert_footpoints( $flocdir, $flocfile, $magfile, $n_fluxons_wanted, $force_process_magnetogram );



#######################################################################################################
## Run the Python PFSS Code ## Trace the Footpoints into the Corona ###################################
#######################################################################################################
# Then we take those root points and use the pfss tracer to map upward from those initial points
# into the corona to define an initial placeholder geometry.
# This lets us extend this into 3d space with real linking topology.
    my $pfss_command =
    "$pythondir $pipedir/get_pfss.py --force $do_pfss --batch $batch_name --reduce $reduction " .
                        "--datdir $datdir --cr $CR --magfile $magfile --nwant $n_fluxons_wanted";

    system($pfss_command) == 0 or ( die "Python script returned error $?", exit );



#######################################################################################################
## Generate World from PFSS ###########################################################################
#######################################################################################################
    # Define the output directory
    my $world_out_dir   = "$datdir/batches/$batch_name/cr$CR/world";
    my $floc_path       = "$datdir/batches/$batch_name/cr$CR/floc";
    my $open_file       = "$floc_path/floc_open_cr$CR\_r$reduction\_f$n_fluxons_wanted.dat";
    my $closed_file     = "$floc_path/floc_closed_cr$CR\_r$reduction\_f$n_fluxons_wanted.dat";

    # Plot the field map
    my $fmap_command = "$pythondir $pipedir/plotting/plot_fieldmap.py --cr $CR --open $open_file" .
                        " --closed $closed_file --batch $batch_name --nwant $n_fluxons_wanted";

    system($fmap_command) == 0 or ( die "Python script returned error $?", exit );

    # Make the world
    make_world_from_pfss(
        $world_out_dir, $floc_path,        $open_file, $closed_file,
        $makeworld,     $CR,               $datdir,    $batch_name,
        $N_actual,      $n_fluxons_wanted, $lim,       $lim2
    );

#######################################################################################################
## Relax the initial world state ##Use the FLUX Code ##################################################
#######################################################################################################
# Then we take that initial guess from pfss.py and relax down using the fluxon code, which gets us realistic topology, and a near force-free state,
# but allowing for currents (not a potential field any longer).

    # Select the World
    $world_out_dir   = $datdir . "/batches/$batch_name/cr" . $CR . '/world/';
    my $full_world_path = $world_out_dir . 'cr' . $CR . "_f$n_fluxons_wanted.flux";
    ( my $this_world_orig, $this_world_relaxed, my $stepnum ) = relax_pfss_world(
        $world_out_dir, $full_world_path,  $do_relax,
        $do_steps,      $relax_threshold,  $max_cycles,
        $logfile,       $n_fluxons_wanted, $N_actual,
        $datdir,        $batch_name,       $CR
    );

#######################################################################################################
## Plot the world states  #############################################################################
#######################################################################################################
    plot_worlds(
        $this_world_orig,  $this_world_relaxed, $do_interactive,
        $do_png,           $full_world_path,    $datdir,
        $batch_name,       $CR,                 $N_actual,
        $n_fluxons_wanted, $lim,                $lim2,
        $stepnum
    );

}

#######################################################################################################
## Begin solar wind computation  ######################################################################
#######################################################################################################
my ( $out_b, $out_fr, $out_wind ) = get_wind( $this_world_relaxed, $datdir,
            $batch_name, $CR, $N_actual, $recompute, $n_fluxons_wanted, $pythondir );

#######################################################################################################
## Plot the Solar wind Solutions  #####################################################################
#######################################################################################################

print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");
print("(py) Plotting Solar Wind Maps for CR$CR\n");
print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n");

system(
"$pythondir $pipedir/plotting/plot_bmag.py --cr $CR --batch $batch_name --dat_dir $datdir " .
                    "--file $out_b --nwant $n_fluxons_wanted"
) == 0 or ( die "Python script returned error $?", exit );
system(
"$pythondir $pipedir/plotting/plot_fr.py --cr $CR --batch $batch_name --dat_dir $datdir " .
                    "--file $out_fr --nwant $n_fluxons_wanted"
) == 0 or ( die "Python script returned error $?", exit );
system(
"$pythondir $pipedir/plotting/plot_wind_map_detailed.py --cr $CR --batch $batch_name " .
                    "--dat_dir $datdir --nwant $n_fluxons_wanted --file $out_wind"
) == 0 or ( die "Python script returned error $?", exit );

## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Count the total time and write to file
my $after         = clock_gettime();
my $elapsed       = $after - $very_beginning;
my $round_elapsed = rint( $elapsed * 10 ) / 10;
open( my $fhh, ">>", $logfile ) or die "Cannot open file: $!";
printf $fhh "ttime: $round_elapsed";
close $fhh;

print
"--------------------------------------------------------------------------------------------------\n";
print
"\tProgram Complete for CR$CR in $round_elapsed Seconds, press RETURN to exit...\n";
print
"--------------------------------------------------------------------------------------------------\n";
print "|\n|\n|\n|\n|\n|\n|\n|\n|\n|";

# system("python3 plot_scalability.py") == 0 or (die "Python script returned error $?", exit);
# <STDIN>;  # Wait for user input

1;

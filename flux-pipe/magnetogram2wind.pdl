# # A script to run the entire FLUX pipeline on a single Carrington Rotation.

# # Note that until the homebrew issues are fixed, plot using the command:
# # $world -> render({'dev'=>'qt'});

# The hilbert curve code defines where fluxons should be rooted based on the distribution of flux at 1R_sun. 
    # Since each contains a discretized amount of magnetic flux, we need to subdivide the domain to reflect how to represent that with fluxons.

# Then we take those root points and use the pfss tracer to map upward from those initial points into the corona to define an initial placeholder geometry. 
    # This lets us extend this into 3d space with real linking topology.

# Then we take that initial guess from pfss.py and relax down using the fluxon code, which gets us realistic topology, and a near force-free state, 
# but allowing for currents (not a potential field any longer).

# use strict;
use warnings;
use PDL::AutoLoader;
use PDL;
use PDL::Transform;
use PDL::NiceSlice;
use PDL::Options;
# use PDL::ImageND;
use Flux;
use PDL::IO::Misc;
use File::Path;
use PDL::IO::Misc;
use Time::HiRes qw(clock_gettime sleep);
use File::Basename qw(fileparse);

# use PDL::Graphics::TriD;
$do_download =          0;
$force_process_magnetogram =  0;
$do_pfss =              0;
$makeworld =            0;
$do_relax =             0;
$do_png =               0;
$do_interactive =       0; 
$do_wind_calc =         0;

# $PDL::BIGPDL = 1;
$do_steps = 1000; # relaxation steps between checking stiffness target
$relax_threshold = 0.49; # stiffness target to stop relaxation
$max_cycles = 10; 

$do_interactive = 0; #will open a gnuplot window
$CR = $ARGV[0] || 2193;
$reduction = $ARGV[1] || 5;
$recompute = $ARGV[3] || 0;
$n_fluxons_wanted = $ARGV[4] || 1000;
# $top_time = clock_gettime();
# $stepnum=0;
$do_wind_calc = 1; ## Calculate the Solar Wind
$batch = $ARGV[5];
$batch_name = "default_batch";
if ($batch) {
    $batch_name = $batch;
}

$lim = 2.5;
$lim2 = 7.5;


## TODO make the wind calculation less verbose

#######################################################################################################
## Job Settings #######################################################################################
#######################################################################################################

if ($recompute){
# ## Download the magnetogram from JSOC
    # $do_download = 1; #1; # $ARGV[2] || 1;
    $force_process_magnetogram = 1; # ## Ingest the magnetogram and find the footpoints of the magnetic field lines
    $do_pfss = 1;
    $makeworld = 1; ## Create the world from the output of the pfss.py code
    $do_relax = 1; ## Top Level Relaxation 
    $do_png = 1; ## Plotting the worlds
}


#######################################################################################################
## Initialize Environment #############################################################################
#######################################################################################################

print "|\n|\n|\n|\n|\n|\n|\n|\n|\n|";
print "\n\n";
print "--------------------------------------------------------------------------------------------------\n";
print "FLUXPipe: Indicate a Carrington Rotation and this script will run the entire Flux Pipeline for it.\n";
print "--------------------------------------------------------------------------------------------------\n";
print "\n\n";

## Set paths
$basedir =  "/Users/cgilbert/vscode";
$codedir =  "$basedir/fluxon-mhd/flux-pipe";
$pdldir =   "$basedir/fluxon-mhd/pdl/PDL";
$datdir =   "$basedir/fluxon-data";
$magdir =   "$datdir/magnetograms";
$batchdir = "$datdir/batches/$batch_name";
$timefile = "$batchdir/pfss_time.txt";

push(@PDLLIB,"+$datdir");
push(@PDLLIB,"+$codedir");
push(@PDLLIB,"+$pdldir");
push(@INC, "/Users/cgilbert/opt");
push(@INC, "/Users/cgilbert/.cpan/build");
push(@INC,"$codedir");

system("cd $codedir");

$ENV{'PYTHONPATH'} = '/opt/homebrew/anaconda3/envs/fluxArm/bin/python3';
$ENV{'FLUXPATH'} = $codedir;
$ENV{'DATAPATH'} = $datdir;

my $pythonpath = $ENV{'PYTHONPATH'};
if (defined $pythonpath) {
    print "\$PYTHONPATH: \t$pythonpath\n";
} else {
    print "PYTHONPATH is not set\n";
    exit();
}

my $datpath = $ENV{'DATAPATH'};
if (defined $datpath) {
    print "\$DATAPATH: \t$datpath\n";
} else {
    print "DATAPATH is not set\n";
    exit();
}

print"\n\n";

if ($recompute) {
    print "\t>>>>>>>>>>>>>>>>>>>>> Recompute = TRUE <<<<<<<<<<<<<<<<<<<<<<<";
} else {
    print "\t>>>>>>>>>>>>>>>>>>>>> Recompute = FALSE <<<<<<<<<<<<<<<<<<<<<<";
}
use Time::Piece;
my $time = localtime;
my $ftime = $time->strftime('%Y-%m-%d %H:%M:%S');
# use PipeHelpers;


print "\n\tStarting FLUXPipe at $ftime \n\tBatch: $batch_name, CR: $CR, Reduction: $reduction, Fluxons: $n_fluxons_wanted";
print "\n\t>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<\n";
print "\n|\n|\n|\n|\n|\n|\n|\n|\n|\n|\n";

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
sleep(1);
$very_beginning = clock_gettime();



#######################################################################################################
## Download the Magnetogram ###########################################################################
#######################################################################################################

$command = "$pythonpath get_magnetograms.py --cr $CR --reduce $reduction --datdir $datdir --do_download $do_download";
system($command) == 0 or (die "Python script returned error $?", exit);



#######################################################################################################
## Process the Magnetogram ## Find the Root Points ####################################################
#######################################################################################################
# The hilbert curve code defines where fluxons should be rooted based on the distribution of flux at 1R_sun. 
# Since each contains a discretized amount of magnetic flux, we need to subdivide the domain to reflect how to represent that with fluxons.

$flocdir = "$batchdir/cr$CR/floc";
$flocfile = "$flocdir/floc_cr$CR\_r$reduction\_f$n_fluxons_wanted.dat";
$magfile = $magdir."/CR$CR\_r$reduction\_hmi.fits";
$N_actual = get_hilbert_footpoints($flocdir, $flocfile, $magfile, $n_fluxons_wanted, $force_process_magnetogram);



#######################################################################################################
## Run the Python PFSS Code ## Trace the Footpoints into the Corona ###################################
#######################################################################################################
# Then we take those root points and use the pfss tracer to map upward from those initial points 
# into the corona to define an initial placeholder geometry. 
# This lets us extend this into 3d space with real linking topology.

$command = "$pythonpath get_pfss.py --force $do_pfss --batch $batch_name --reduce $reduction --datdir $datdir --cr $CR --magfile $magfile --nwant $n_fluxons_wanted";
system($command) == 0 or (die "Python script returned error $?", exit);



#######################################################################################################
## Generate World from PFSS ###########################################################################
#######################################################################################################

# Define the output directory
$world_out_dir = "$datdir/batches/$batch_name/cr$CR/world";
$floc_path   = "$datdir/batches/$batch_name/cr$CR/floc";
$open_file   ="$floc_path/floc_open_cr$CR\_r$reduction\_f$n_fluxons_wanted.dat";
$closed_file ="$floc_path/floc_closed_cr$CR\_r$reduction\_f$n_fluxons_wanted.dat";

# Plot the field map
system("$pythonpath plotting/plot_fieldmap.py --cr $CR --open $open_file --closed $closed_file --batch $batch_name") == 0 or (die "Python script returned error $?", exit);

# Make the world
make_world_from_pfss($world_out_dir, $floc_path, $open_file, $closed_file, $makeworld, $CR, $datdir, $batch, $N_actual, $n_fluxons_wanted, $lim, $lim2);


#######################################################################################################
## Relax the initial world state ##Use the FLUX Code ##################################################
#######################################################################################################
# Then we take that initial guess from pfss.py and relax down using the fluxon code, which gets us realistic topology, and a near force-free state, 
# but allowing for currents (not a potential field any longer).

# Select the World
$n_outliers = 0; # THIS IS FUDGE CODE!
$n_remaining = $N_actual - $n_outliers;
$world_out_dir = $datdir."/batches/$batch_name/cr".$CR.'/world/';
$full_world_path = $world_out_dir .'cr'.$CR."_f$n_remaining.flux";
our ($this_world_orig, $this_world_relaxed) = relax_pfss_world($world_out_dir, $full_world_path, $do_relax, $do_steps, $relax_threshold, $max_cycles, $timefile, $n_fluxons_wanted, $N_actual, $datdir, $batch_name, $CR, $n_outliers);



#######################################################################################################
## Plot the world states  #############################################################################
#######################################################################################################

plot_worlds($this_world_orig, $this_world_relaxed, $do_interactive, $do_png, $full_world_path, $datdir, $batch_name, $CR, $N_actual, $lim, $lim2);



#######################################################################################################
## Begin solar wind computation  ######################################################################
#######################################################################################################

get_wind($this_world_relaxed, $datdir, $batch_name, $CR, $N_actual, $recompute);



## ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
## Count the total time and write to file
$after   = clock_gettime();
$elapsed = $after - $very_beginning;
$round_elapsed = rint($elapsed*10) / 10;
open($fhh, ">>", $timefile) or die "Cannot open file: $!";
    printf $fhh "ttime: $round_elapsed";
close $fhh;
print "\n \n**Program Complete for CR$CR in $round_elapsed Seconds, press ENTER to exit...\n\n\n";



# system("python3 plot_scalability.py") == 0 or (die "Python script returned error $?", exit);
# <STDIN>;  # Wait for user input

1;
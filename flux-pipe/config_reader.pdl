package ConfigManager;

# use strict;
use warnings;
use JSON;
use Config::IniFiles;
use Carp qw(croak);
use Exporter qw(import);
use List::Util qw(max);
use Data::Dumper;
use Cwd 'abs_path';
use File::HomeDir;
use File::Slurp;
use File::Copy;
use File::Find;
# use strict;
# use warnings;
# use File::Find;
use Cwd;

our @EXPORT_OK = qw(manage_variable print_all_variables print_all_configs select_vars_file select_config_file get_configs get_vars update_section);


our %config_box;
our %the_config;
our $selected_section = "DEFAULT";
my $last_print = 0;

our $default_dir;
our $vars_filename;
our $config_box_filename;
our $start_path;

$default_dir = $ENV{'FL_PREFIX'} ? "$ENV{'FL_PREFIX'}/flux-pipe/config" : "flux-pipe/config";
$vars_filename = "$default_dir/variables.json";
$config_box_filename = "$default_dir/config.ini";


##############################################################################
# Config File ################################################################


# Function to select config file
sub select_config_file {
    my ($filename, $section) = @_;
    my $vars;
    if (not defined $filename) {
        ($filename, $vars) = find_config_ini();
    }
    our $selected_section;
    $section //= $selected_section;
    open my $fh, '<', $filename or croak "Could not open config file: $filename";
    parse_config_file($fh, $section);
    close $fh;
    return;
}


sub find_config_ini {
    my ($start_dir) = @_;
    my @found_files;
    our $config_box_filename;
    our $vars_filename;
    our $start_path;
    # If no start directory is provided, find 'fluxon-mhd' in the current directory or its superdirectories
    unless (defined $start_dir) {
        my $current_dir = cwd();
        while ($current_dir ne '/') {
            if ($current_dir =~ /fluxon-mhd$/) {
                $start_dir = $current_dir;
                last;
            }
            # Move up one directory level
            $current_dir =~ s{/[^/]+$}{};
        }
        die "Could not find 'fluxon-mhd' directory" unless defined $start_dir;
        $start_path = $start_dir;
    }

    # print "start_dir: $start_dir->[0]\n";

    find(sub {
        return unless -f;  # Skip directories and other non-files
        return unless $_ eq 'config.ini';  # Look for "config.ini"
        push @found_files, $File::Find::name;
    }, $start_dir);


    find(sub {
        return unless -f;  # Skip directories and other non-files
        return unless $_ eq 'variables.json';  # Look for "config.ini"
        push @found_files, $File::Find::name;
    }, $start_dir);

    # print "\n\n\n";
    # print $start_dir . "\n";
    # print @found_files;

    if (scalar @found_files == 2) {
        $config_box_filename = $found_files[0];
        $vars_filename = $found_files[1];
        return $config_box_filename, $vars_filename;
    } else {
    croak "Could not locate either config.ini or variables.json";
    }
}

# Function to parse the config file
sub parse_config_file {
    my ($fh, $section) = @_;
    # print "\n\n\nTHIS IS BOGUS\n\n\n";
    our %config_box;
    # %config_box = get_all_sections($fh);

    my $current_section = ""; #$section;
    #This loads every section of the file into a hash
    # our %config_box;
    while (<$fh>) {
        chomp;
        next if /^\s*$/;
        next if /^\s*#/;
        if (/^\s*\[(.+)\]\s*$/) {
            # print "\n\n";
            $current_section = $1;
            $config_box{$current_section} = {} unless exists $config_box{$current_section};
        } elsif (/^\s*(\w+)\s*=\s*(.+)\s*$/) {
            my $key = lc $1;  # Convert the key to lowercase
            # print "Key: $key : " . $2 . "\n";
            $config_box{$current_section}{$key} = $2;
        }
    }

    croak "Section not found: $section" unless exists $config_box{$section};

    # Check if the 'DEFAULT' section exists
    if (exists $config_box{'DEFAULT'}) {
        # Iterate through each section in %config_box
        foreach my $section (keys %config_box) {
            # Skip the 'DEFAULT' section itself
            next if $section eq 'DEFAULT';

            # Debug: Print the current section
            # print "Merging section: $section\n";

            # Merge the current section with the 'DEFAULT' section
            %{$config_box{$section}} = (%{$config_box{'DEFAULT'}}, %{$config_box{$section}});
        }
    }



    $selected_section = $section;
    our %the_config;
    %the_config = %{$config_box{$section}};
    return $the_config # Return hash reference
}



    # Import configs from DEFAULT and overwrite with the selected section
    # if ($section ne 'DEFAULT' && exists $config_box{'DEFAULT'}) {
    #     %{$config_box{$section}} = (%{$config_box{'DEFAULT'}}, %{$config_box{$section}});
    # }
    # Debug: Print the content of %config_box before merging
    # print "Before merging:\n";
    # print Dumper(\%config_box);

    # # Debug: Print the content of %config_box after merging
    # print "After merging:\n";
    # print Dumper(\%config_box);

# sub get_all_sections {
#     my ($fh) = @_;
#     my $current_section = ""; #$section;
#     #This loads every section of the file into a hash
#     # our %config_box;
#     while (<$fh>) {
#         chomp;
#         next if /^\s*$/;
#         next if /^\s*#/;
#         if (/^\s*\[(.+)\]\s*$/) {
#             $current_section = $1;
#             $config_box{$current_section} = {} unless exists $config_box{$current_section};
#         } elsif (/^\s*(\w+)\s*=\s*(.+)\s*$/) {
#             my $key = lc $1;  # Convert the key to lowercase
#             # print "Key: $key : " . $2 . "\n";
#             $config_box{$current_section}{$key} = $2;
#         }
#     }
#     return %config_box;  # Return hash reference
# }


# Function to print available sections
sub print_available_sections {
    print "Available sections: ", join(", ", keys %config_box), "\n";
    return;
}

# Function to update the current section
sub update_section {
    my $new_section = shift;
    defined $new_section ? select_config_file($config_box_filename, $new_section) : print_available_sections();
    return;
}

# # Function to print all configs
# sub print_all_configs {
#     my $section = shift // $selected_section;
#     our %the_config;
#     # croak "Section not found: $section" unless exists %the_config;
#     print "\n[$section]\n";
#     print "\t$_ \t=  $the_config{$_}\n" for sort keys $the_config;
#     print "\n";
#     return;
# }

# Function to print all configs
sub print_all_configs {
    my $section = shift // $selected_section;
    our %config_box;

    # Check if the section exists in the config hash
    unless (exists $config_box{$section}) {
        print "Section not found: $section\n";
        return;
    }

    print "\n[$section]\n";

    # Iterate through the keys in the given section and print them
    for my $key (sort keys %{ $config_box{$section} }) {
        print "\t$key \t=  $config_box{$section}{$key}\n";
    }

    print "\n";
    return;
}

# Function to get configs
sub get_configs {
    my ($should_print, $section) = @_;

    $should_print //= 0;  # Default to 0

    if (defined $section) {
        update_section($section);
        print "Updated section: $section\n";
    } else {
        $section = $selected_section;
    }
    croak "Section not found: $section" unless exists $config_box{$section};  # Using hash syntax

    our %the_config;
    our %config_box;
    # $the_config = $config_box{$section};
    %the_config = %{ $config_box{$section} };


    #TODO Add these

    if ($should_print) {print "\n(pdl) Configuration loaded!\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";}

    if ($should_print && exists $the_config{'verbose'} && $the_config{'verbose'}) {  # Using arrow syntax
    # if ($should_print && exists $the_config{verbose} && $the_config{verbose}) {  # Added exists check
        if ($last_print ne $section) { print_all_configs($section); }
        $last_print = $section;
    }

    return $the_config;  # Return hash reference
}

sub prep_array{
    my $str = shift;
    # Remove square brackets
    $str =~ s/[\[\]]//g;

    # Split string by comma and create an array
    my @array = split /,\s*/, $str;

    return \@array;
}

sub calculate_secondaries {

    our %the_config;
    our %config_box;
  # Using hash syntax
    # print $the_config{'rotations'};

    $the_config{'rotations'} = prep_array($the_config{'rotations'});
    $the_config{'fluxon_count'} = prep_array($the_config{'fluxon_count'});

    # Check if rotations and fluxon_count are defined before dereferencing
    if (defined $the_config{'rotations'} && defined $the_config{'fluxon_count'}) {
        $the_config{'n_jobs'} = scalar(@{$the_config{'rotations'}}) * scalar(@{$the_config{'fluxon_count'}});
    } else {
        warn "Either rotations or fluxon_count is undefined. Cannot calculate n_jobs.";
    }

    my $rc_path = $the_config{'rc_path'};
    if ($rc_path =~ /^~\//) {
        my $home = File::HomeDir->my_home;
        $rc_path =~ s/^~/$home/;
    }

    my $abs_rc_path = abs_path($rc_path);
    $the_config{'abs_rc_path'} = $abs_rc_path;

    # Concatenate paths
    use File::Spec;
    $the_config{'run_script'} = File::Spec->catfile($the_config{'fl_prefix'}, $the_config{'run_script'});
    my $section = $the_config{'name'};
    # print %the_config;
    # print "\n\n\n";
    # print $config_box{$section};
    $config_box{$section} = \%the_config;
    my $a = 1;
}
##############################################################################
# Environment Variables


# sub set_env {
#     my ($key, $value, $RC_FILE_PATH, $verbose) = @_;

#     # Check and set the environment variable
#     if (!exists $ENV{$key} || $ENV{$key} ne $value) {
#         delete_lines($RC_FILE_PATH, $key);
#         $ENV{$key} = $value;

#         # Append to the RC file
#         append_file($RC_FILE_PATH, "export $key=$value\n");

#         if ($verbose) {
#             print "\tSet $key to $ENV{$key}\n";
#         }
#     }
#     return $ENV{$key};
# }

# Get an environment variable with a default value


# List all environment variables and their values
sub get_envs {
    my ($verbose, $print_all) = @_;
    $verbose //= 0;  # Default value for verbose
    $print_all //= 0;   # Default value for silent


    if ($verbose) {
        print "\nLoading Envs... Done!\n";
        if ($print_all){
            print "\nEnvironment Variables:\n~~~~~~~~~~~~~~~~~~~~~~~\n";
            print_all_envs();
        }
    }


    return \%ENV;  # Return a reference to %ENV
}

# Pretty-print all environment variables
sub print_all_envs {
    # Find the length of the longest key for alignment
    my $max_key_length = 0;
    foreach my $key (keys %ENV) {
        $max_key_length = length($key) if length($key) > $max_key_length;
    }

    foreach my $key (sort keys %ENV) {
        my $value = $ENV{$key};
        if ($value =~ /:/) {
            my @vals = split /:/, $value;
            print "\n", $key, ' ' x ($max_key_length - length($key)), "  =  ", shift @vals, "\n";
            print ' ' x $max_key_length, "  >", $_, "\n" for @vals;
            print "\n";
        } else {
            printf "%*s = %s\n", $max_key_length, $key, $value;

            # print $key, ' ' x ($max_key_length - length($key)), "  =  ", $value, "\n";
        }
    }
}

sub get_env {
    my ($key, $default) = @_;
    return exists $ENV{$key} ? $ENV{$key} : $default;
}

sub set_env {
    my ($key, $value, $RC_FILE_PATH, $verbose) = @_;
    # print $key, $value, $RC_FILE_PATH, $verbose;

    # Check for undefined values
    return unless defined $key;
    $value = '' unless defined $value;

    $RC_FILE_PATH = $the_config{'abs_rc_path'} unless defined $RC_FILE_PATH;
    $verbose = 0 unless defined $verbose;

    # Check and set the environment variable
    if (!exists $ENV{$key} || $ENV{$key} ne $value) {
        $ENV{$key} = $value;

        if (defined $RC_FILE_PATH) {
            # Append to the RC file
            delete_lines($RC_FILE_PATH, $key);
            append_file($RC_FILE_PATH, "export $key=$value\n");
        }

        if ($verbose) {
            print "\tSet $key to $ENV{$key}\n";
        }
    }
    return $ENV{$key};
}


sub delete_lines {
    my ($original_file, $strings_to_delete, $temp_file) = @_;
    $temp_file //= 'temp.txt';  # Default value for temp_file

    # Convert a single string to an array reference
    if (ref $strings_to_delete ne 'ARRAY') {
        $strings_to_delete = [$strings_to_delete];
    }

    open my $file, '<', $original_file or die "Could not open $original_file: $!";
    open my $temp, '>', $temp_file or die "Could not open $temp_file: $!";

    while (<$file>) {
        my $line = $_;
        my $should_write = 1;

        foreach my $string (@$strings_to_delete) {
            if (index($line, $string) != -1) {
                $should_write = 0;
                last;
            }
        }

        if ($should_write) {
            print $temp $line;
        }
    }

    my $x = close $file;
    my $xx = close $temp;

    unlink $original_file or die "Could not delete $original_file: $!";
    move($temp_file, $original_file) or die "Could not rename $temp_file to $original_file: $!";
    return;
}

sub list_all_env {
    # List all environment variables and their values
    while (my ($key, $value) = each %ENV) {
        print "$key = $value\n";
    }
    return
}




##############################################################################
# Variables File #############################################################

# Helper function to read JSON data from a file
sub read_json_file {
    my $filename = shift;
    open my $fh, '<', $filename or croak "Could not open file '$filename' $!";
    my $json_text = do { local $/; <$fh> };
    close $fh;
    return from_json($json_text);
}

# Helper function to write JSON data to a file
sub write_json_file {
    my ($data, $filename) = @_;
    $filename //= $vars_filename;  # Use $vars_filename if $filename is not provided
    open(my $fh, '>', $filename) or croak "Could not open file '$filename': $!";
    print $fh to_json($data);
    close $fh;
    return;
}

# Helper function to ensure JSON file exists
sub ensure_json_file_exists {
    write_json_file({}, $vars_filename) unless -e $vars_filename;
    return;
}

# Function to select variables file
sub select_vars_file {
    $vars_filename = shift;
    ensure_json_file_exists();
    return;
}

# Function to delete all variables from JSON file
sub delete_all_vars {
    my $should_print = shift // 0;  # Default value set to 0
    # Write an empty JSON object to the file
    write_json_file({}, $vars_filename);  # Note the addition of $vars_filename
    print "\nAll variables have been deleted from the JSON file.\n" if $should_print;
    return;
}

# Function to set a variable
sub set_variable {
    my ($var_name, $new_value) = @_;
    ensure_json_file_exists();
    my $data = read_json_file($vars_filename);
    $data->{$var_name} = $new_value;
    write_json_file($data, $vars_filename);
    return $new_value;
}

# Function to get a variable
sub get_variable {
    my ($var_name) = @_;
    ensure_json_file_exists();
    my $data = read_json_file($vars_filename);
    if (!exists $data->{$var_name}) {
        croak "Variable not found: $var_name";
    }
    return $data->{$var_name};
}

# Function to print all variables
sub print_all_variables {
    my $data = shift;
    print "\nAll variables from JSON file:\n\n";

    if (%$data) {
        my $max_key_length = max(map { length } keys %$data);
        for my $key (sort keys %$data) {
            printf "\t%-*s : %s\n", $max_key_length, $key, $data->{$key};
        }
    } else {
        print "\tNo variables found.\n";
    }
    print "\n";
    return;
}

# Function to get variable values from JSON file
sub get_vars {
    my $should_print = shift // 0;  # Default value set to 0
    ensure_json_file_exists();
    my $data = read_json_file($vars_filename);

    # Access the configs hash
    my $configs = get_configs();  # Note that it's a scalar now

    # Check if 'verbose' is true and print accordingly
    print_all_variables($data) if $should_print && $the_config{'verbose'};

    return $data;
}

##############################################################################
# Helper Functions

# Function to initialize default files
sub initialize_files {
    my $verb = shift // 0;

    if (not -e $config_box_filename or not -e $vars_filename){
        ($config_box_filename, $vars_filename) = init_paths();
    }

    if (-e $config_box_filename) {
        # First, load the DEFAULT section to get CONFIG_NAME
        select_config_file($config_box_filename, 'DEFAULT2');
        my $config_box_name = $config_box{'DEFAULT2'}{'config_name'} // 'DEFAULT2';  # Use 'DEFAULT' if CONFIG_NAME is not set

        # Now, load the section named by CONFIG_NAME
        if (exists $config_box{$config_box_name}) {
            update_section($config_box_name);
        } else {
            print "Section '$config_box_name' not found. Available sections are: ", join(", ", keys %config_box), "\n";
        }
    } else {
        print "Please select the config file using 'select_config_file'.\n";
    }
    calculate_secondaries();

    select_vars_file($vars_filename);

    set_all_base_envs();


    ($configs, $vars, $envs) = get_all($verb);

    return ($configs, $vars, $envs);
}

sub set_all_base_envs() {
    our %the_config;
    our $start_path;
        # Set the perl and flux paths
    set_env('RC_PATH',      $the_config{'rc_path'},      $the_config{'abs_rc_path'});
    set_env('ABS_RC_PATH',  $the_config{'abs_rc_path'},  $the_config{'abs_rc_path'});
    set_env('PL_PREFIX',    $the_config{'pl_prefix'},    $the_config{'abs_rc_path'});
    # set_env('FL_PREFIX', $start_path);
    set_env('FL_PREFIX',    $the_config{'fl_prefix'},    $the_config{'abs_rc_path'});
    set_env('WHICH_CONFIG', $the_config{'config_name'},  $the_config{'abs_rc_path'});
    # print get_env('ABS_RC_PATH');
    return;
}

sub init_paths(){
    use Cwd;

    my $current_directory = cwd();
    # print "\nCurrent directory: $current_directory\n";

    our $default_dir;
    our $vars_filename;
    our $config_box_filename;
    $default_dir = $ENV{'FL_PREFIX'} ? "$ENV{'FL_PREFIX'}/flux-pipe/config" : "flux-pipe/config";
    $vars_filename = "$default_dir/variables.json";
    $config_box_filename = "$default_dir/config.ini";

    if (not -e $config_box_filename){
        ($config_box_filename, $vars_filename) = find_config_ini();
    }
    return $config_box_filename, $vars_filename;
}

sub get_all() {
    my $verb = shift // 0;
    my $envs    = get_envs($verb, $verb);
    my $configs = get_configs($verb);
    my $vars    = get_vars($verb);
    return ($configs, $vars, $envs);}

##############################################################################
if ($0 eq __FILE__) {
    # Call the initialization function at the end
    my ($configs, $vars, $envs) = initialize_files(0);

    # At the end of your Perl file

    # This block will only run if the file is called directly

    my $verb = 0;
    if ($verb) {print "\n\nThis file is being run directly.\n";}


    # get_all()
    # get_configs(undef, $verb);
    # set_variable("Testy", 125);
    # set_variable("Variable", 100);

    # my $configs = get_configs("Test_Config");  # Note the % instead of $
    # my $configs = get_configs(undef, $verb);
    # delete_all_vars($verb);
    # my $vars = get_vars($verb);

    ## Useful Functions
    # set_variable("key", "value");
    # my $vars = get_vars();
    # my configs = get_configs("Section Name");
    # delete_all_vars();

    # print($vars->{"Testy"} . "\n");

    # my $key = "batch_name";
    # print $key . $configs{$key} . "\n";  # Now this should work

    # # # To get a specific config value
    # my $key = "batch_name";
    # my $val = $configs->{$key};
    # print "$key: $val\n";
    }

1;

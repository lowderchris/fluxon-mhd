use PDL::NiceSlice;
=head2 gen_fluxon_flow

=for ref

Given a fluxon and some options, calculate the flow and density in the fluxon if it is open (or leave it blank if it is closed).

Returns a 2xN PDL, containing (r, vr).  By default, it also updates these fields in the fluxon itself. Returns two PDLs containing the starting / ending theta and phi values for the fluxon.

If the fluxon is doubly open or doubly closed or a plasmoid, return udnef.

=cut
use PDL::Options;
use Math::RungeKutta;
use PDL::GSL::INTEG;

sub gen_fluxon_flow {
    my $me = shift;
    my $u_opt = shift // {};

    # Define and append optional option input
    my %opt = parse( {
        steps => 500,
        g0 => 280,      # m/s^2
        r0 => 696e6,    # m
        v0 => 10,       # km/sec
        cs => 180,      # km/sec at 2e6K and fully ionized protons
                        },
                        $u_opt
        );

    # Check for start and ending points being open
    our $st_open = ($me->{fc_start}->{label}==-1);
    our $en_open = ($me->{fc_end}->{label}==-2);

    # Return undefined value if the given fluxon structure is labeled as a plasmoid, or if
    #   both ends are open
    return undef if( $me->{plasmoid} || ($st_open + $en_open != 1));

    # Pass options into local variables
    my $g0 = $opt{g0};
    my $r0 = $opt{r0};
    my $cs = $opt{cs} * 1e3; ## convert to m/s from km/s

    # Calculate array of spherical coordinate positions and areas along the fluxon
    # Work along the correct direction depending on which end is open
    if($en_open) {
        my $x = squeeze($me->dump_vecs->(0));
        my $y = squeeze($me->dump_vecs->(1));
        my $z = squeeze($me->dump_vecs->(2));
        our $r = ($x**2 + $y**2 + $z**2)->sqrt * $opt{r0};
        our $th = acos($z/$r*$opt{r0});
        our $ph = atan2($y, $x);
        our $A = pdl(map {$_->{A}} ($me->vertices)) * $opt{r0} * $opt{r0};
    } else {
        my $x = squeeze($me->dump_vecs->(0,-1:0:-1));
        my $y = squeeze($me->dump_vecs->(1,-1:0:-1));
        my $z = squeeze($me->dump_vecs->(2,-1:0:-1));
        our $r = ($x**2 + $y**2 + $z**2)->sqrt * $opt{r0};
        our $th = acos($z/$r*$opt{r0});
        our $ph = atan2($y, $x);
        our $A = pdl(map { $_->{A}} ($me->vertices))->(-1:0:-1) * $opt{r0} * $opt{r0};
    }

    # Get rid of end anomalies
    # CL - Equating these values does make for some strange end/open point behavior later...
    $A->((0)) .= $A->((1));
    $A->((-1)) .= $A->((-2));

    # Define gravitational acceleration g as a function of radius
    our $g = $g0 * ($opt{r0} / $r)**2;

    # Define an expansion factor
    our $fr = $A / $A->((0)) * $opt{r0} * $opt{r0} / $r / $r;

    # Smooth slightly to remove numerical issues
    $fr->inplace->convolveND(pdl(1,2,3,2,1)/9,{bound=>'e'});
    our $dfr_dr = $fr->copy;

    # Calculate numerical derivatives
    $dfr_dr->(1:-2) .= ($fr->(2:-1) - $fr->(0:-3))/($r->(2:-1) - $r->(0:-3));
    $dfr_dr->(0) .= ($fr->(1) - $fr->(0)) / ($r->(1) - $fr->(0));
    $dfr_dr->(-1) .= ($fr->(-1) - $fr->(-2)) / ($r->(-1) - $r->(-2));

    # Chunk of code to calculate
    $dydx = sub {
        my $rnow = shift;
        #my $vnow = shift;

        my $front = $vnow/$rnow;
        my $denominator = $cs * $cs  -  $vnow * $vnow;

        my ($gnow,$gerr) = interpolate($rnow,$r,$g);
        my ($frnow,$frerr) = interpolate($rnow,$r,$fr);
        my ($dfr_drnow,$dfrerr) = interpolate($rnow,$r,$dfr_dr);
        #my $dfr_drnow = 0;

        my $numerator = $gnow * $rnow   -   2 * $cs * $cs * (  1   +   $rnow / 2 / $frnow * $dfr_drnow  );
        #return ($front * $numerator / $denominator, $numerator, $denominator);
        return $front * $numerator / $denominator;
    };

    # Calculate average steps in r
    $dr = ($r->max - $r->min) / $opt{steps};

    # Define v0 and r0 values, and push into a list for storage
    @rv = ();
    our $vnow = $opt{v0} * 1e3; # Convert to m/sec from km/sec
    $rnow = $r->minimum;
    push(@rv, pdl($rnow,$vnow));

    # Create some empty list for storage of numerators and denominators
    @num = ();
    @denom = ();

    my ($dvdr, $oldnum, $olddenom) = &$dydx($rnow,$vnow);

    for ($step=0; $step<$opt{steps};$step++){
        #($rnow, $vnow) = rk4([$vnow], \&$dydx, $rnow, $dr);
        ($vint, $abserr, $ierr) = gslinteg_qags($dydx, $rnow, $rnow+$dr, 0, 1e-6, 1000,{Warn => 'y'});
        $rnow += $dr;
        $vint = squeeze($vint);
        $vnow += $vint;
        push(@rv, pdl($rnow,$vnow));
    }

    # Return a list of r and v values, in units of r_sun and m/s
    return (pdl(@rv) * pdl(1.0/$opt{r0},1e-3), pdl($r/$opt{r0}, $fr), pdl($th(0), $th(-1)), pdl($ph(0), $ph(-1)));
}

__END__
